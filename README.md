# File Management System Project

Hello and welcome! This document contains insight into my process of designing and building a simple File Manager! 

If you would like to jump straight into using the FMS find out how [here](https://example).


# Document Contents

- **Project Significance**: What is a File Management System and why build your own custom File Management System
- **Design Phase + Technical Insights**: This section will discuss some challenges I faced, what I did to overcome them.
- **Technical Insights**: For all you nerds out there! This section will talk about technical considerations.
- **Building Process**: Duri
- **Reflection**: During this section, we will discuss the end product, some expectations that did not turn out as planned, and all the lessons I learned on the way.
- **Conclusion**: Here you will find a summary of the project, how you can contribute, as well as new things I will work on in the future.





# Project Significance

## What is a File Management System?

A File Management System (FMS) enables users to manage and organise digital files efficiently. Popular examples include Windows' File Explorer and macOS's Finder. These applications offer users a wide range of management tools through a clean and intuitive interface, enhancing usability and functionality. Core FMS functions include creating, moving, renaming, deleting files and folders.


## The Why?

You might wonder, 'Why create a custom FMS with options like File Explorer and Finder available?' The answer lies in the unique learning opportunities and the abiblity to surpass the limitations of traditional systems.
With the ability to impliment any desired functionality, a custom built FMS allows tailor made functions that File Explorer/ Finder cannot perform, with the extent of customisation left in the hands of the person creating the system, and their specific needs. 

A custom built FMS provides the following opportunities:

- **Edicational Tool**: A lesson in object oriented programming, file IO, and exception handling.
- **Customized Workflow**: Create tailor made functionalities for specific needs.
- **Cross Platform Compatibility**: Can be designed to work across different operating systems.
- **Automation**: Automate routine tasks.
- **Learning and Experimentation**: The development of such a system can serve as a sandbox for experimenting with python libraries, exploring data structures, and building user interfaces.






# Design Phase

## Project Overview

**Project Statement and Scope**: The goal of this project is to develop a custom built file management system with python, utilising object oriented programming techniques. This process will also invlove the implementation of File IO operations and exception handling.

**Objective**: The objective of this project is to apply the python concepts mentioned above to create a user friendly custom built file management system. This system will be designed to store, retrieve, and manage documents or records in the form of text files, acting as a simple database.

**Philosophy of project**: Start Small: Begin with core functionalities that are common to all operating systems, and gradually expand features and capabilities.

## Tools

(Python, Github, Coding IDE) Built-in Libraries (os, shutil, pathlib)

## Functional Requirements

The File Management System must be able to:

- Creating, reading, updating, and deleting files (CRUD operations).
- Organizing files into directories based on categories or tags.
- Searching for files based on name, content, or metadata.


## Non-Functional Requirements

The File Management System should:

- Work through the Command Line.
- Have a clean aesthetic with clear prompts and feedback messages.
- Cross platform compatibility.
- Have intuitive commands and seemless execption handling.
- Uncluttered code built with the potential of expansion and modification in mind.


## Design and Architecture

**Basic Flow**: Welcome message, display available actions and corresponding number, accept a number as input, prompt for any relevent additinal input, perform action. Cancel/ back + exit appliction functionality.

**Code**: Import required libraries, define classes, implement file operations, account for exeption handling.


This covers the design phase of the project. Next, we will cover how to use the finished product, how I arrived at the completion of said product, and what I learned during the process of creating it.



# Building Process


# Reflection




# Conclusion

## Future Work

## Contributions

Contributions are welcome! There are many ways you can contribute to this project:

- **Reporting Bugs**: If you find a bug, please open an issue in the GitHub repository, providing a detailed description of the bug and, if possible, steps to reproduce it.
- **Suggesting Enhancements**: Have ideas on how to improve the calculator? Open an issue to suggest new features or enhancements.
- **Submitting Pull Requests**: Feel free to fork the repository and submit pull requests with bug fixes or feature additions.

Please adhere to the following steps for your contributions to be considered:
- Fork the repository and create your branch from `main`.
- If you've added code, ensure it is well documented and tested.
- Ensure your commit messages clearly describe the changes.
- Open a pull request with a clear title and description.

For more information on how to contribute, please read the [CONTRIBUTING.md](https://github.com/EmiliosRichards/Beginner-Project-Python-Calculator/blob/main/CONTRIBUTING.md) guide in our repository.

### Licence

This project is licensed under the MIT License - see the [LICENSE]([LICENSE_FILE_LINK](https://github.com/EmiliosRichards/Beginner-Project-Python-Calculator/blob/main/LICENSE)) file for details.

### Contact Information

If you have any questions or comments about the project, or if you're interested in contributing, feel free to reach out:

- **Project Maintainer**: Emilios Richards
- **Email**: emiliosmrichards@gmail.com
- **GitHub Profile**: [EmiliosRichards](https://github.com/EmiliosRichards)

### References

- **Python Official Documentation**: The Python documentation (https://docs.python.org/3/) was invaluable for understanding the standard libraries and functions.
- **Stack Overflow**: Various threads and discussions on Stack Overflow (https://stackoverflow.com/) provided solutions and insights for specific programming challenges encountered during the development of the project.
- **GitHub Docs**: The GitHub documentation (https://docs.github.com/en) was a guide for using Git and GitHub for version control and project management, ensuring best practices in code sharing and collaboration.